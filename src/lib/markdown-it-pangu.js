/*!
 * markdown-it-pangu@1.0.2
 * Copyright (c) 2023, Shigma (MIT)
 *
 * License for markdown-it-pangu@1.0.2:
 *
 * MIT License
 *
 * Copyright (c) 2019 Shigma
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * License for pangu@4.0.7:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013 Vinta
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * License for markdown-it@8.4.2:
 *
 * Copyright (c) 2014 Vitaly Puzrin, Alex Kocharin.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 *
 * License for entities@1.1.2:
 *
 * Copyright (c) Felix B√∂hm All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * License for uc.micro@1.0.6:
 *
 * Copyright Mathias Bynens <https://mathiasbynens.be/>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * License for mdurl@1.0.1:
 *
 * Copyright (c) 2015 Vitaly Puzrin, Alex Kocharin.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *
 * --------------------------------------------------------------------------------
 *
 * .parse() is based on Joyent's node.js `url` code:
 *
 * Copyright Joyent, Inc. and other Node contributors. All rights reserved.
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var __node_modules__ = [
[/* 0 */ 'markdown-it-pangu', '/src/index.js', function(exports, module, __filename, __dirname, __meta) {
const pangu = __node_require__(1 /* 'pangu' */)
const { escapeHtml, isWhiteSpace } = __node_require__(3 /* 'markdown-it/lib/common/utils' */)

function getPrevChar (tokens, index) {
  let prevChar = ''
  for (let i = index - 1; i >= 0; i -= 1) {
    const { content, type } = tokens[i]
    if (type === 'html_inline') break
    if (content && content.length) {
      prevChar = content.slice(-1)
      break
    }
  }
  return prevChar
}

module.exports = (md, options = {}) => {
  const { additionalRules = ['code_inline'] } = options

  md.renderer.rules.text = (tokens, index, options, env, self) => {
    const prevChar = getPrevChar(tokens, index)
    return escapeHtml(pangu.spacing(prevChar + tokens[index].content).slice(prevChar.length))
  }

  additionalRules.forEach((type) => {
    const rule = md.renderer.rules[type]
    if (!rule) return

    md.renderer.rules[type] = (tokens, index, options, env, self) => {
      let output = rule(tokens, index, options, env, self)
      if (output.length) {
        if (index > 0 && !isWhiteSpace(output.charAt(0))) output = ' ' + output
        if (index < tokens.length - 1 && !isWhiteSpace(output.charAt(output.length - 1))) {
          output += ' '
        }
      }
      return output
    }
  })
}
}],
[/* 1 */ 'pangu', '/dist/node/index.js', function(exports, module, __filename, __dirname, __meta) {
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var fs = require('fs');

var _require = __node_require__(2 /* '../shared/core' */),
    Pangu = _require.Pangu;

var NodePangu = function (_Pangu) {
  _inherits(NodePangu, _Pangu);

  function NodePangu() {
    _classCallCheck(this, NodePangu);

    return _possibleConstructorReturn(this, _getPrototypeOf(NodePangu).apply(this, arguments));
  }

  _createClass(NodePangu, [{
    key: "spacingFile",
    value: function spacingFile(path) {
      var _this = this;

      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
      return new Promise(function (resolve, reject) {
        fs.readFile(path, 'utf8', function (err, data) {
          if (err) {
            reject(err);
            return callback(err);
          }

          var spacingData = _this.spacing(data);

          resolve(spacingData);
          return callback(null, spacingData);
        });
      });
    }
  }, {
    key: "spacingFileSync",
    value: function spacingFileSync(path) {
      return this.spacing(fs.readFileSync(path, 'utf8'));
    }
  }]);

  return NodePangu;
}(Pangu);

var pangu = new NodePangu();
module.exports = pangu;
module.exports.default = pangu;
module.exports.Pangu = NodePangu;
}],
[/* 2 */ 'pangu', '/dist/shared/core.js', function(exports, module, __filename, __dirname, __meta) {
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var CJK = "\u2E80-\u2EFF\u2F00-\u2FDF\u3040-\u309F\u30A0-\u30FA\u30FC-\u30FF\u3100-\u312F\u3200-\u32FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF";
var ANY_CJK = new RegExp("[".concat(CJK, "]"));
var CONVERT_TO_FULLWIDTH_CJK_SYMBOLS_CJK = new RegExp("([".concat(CJK, "])[ ]*([\\:]+|\\.)[ ]*([").concat(CJK, "])"), 'g');
var CONVERT_TO_FULLWIDTH_CJK_SYMBOLS = new RegExp("([".concat(CJK, "])[ ]*([~\\!;,\\?]+)[ ]*"), 'g');
var DOTS_CJK = new RegExp("([\\.]{2,}|\u2026)([".concat(CJK, "])"), 'g');
var FIX_CJK_COLON_ANS = new RegExp("([".concat(CJK, "])\\:([A-Z0-9\\(\\)])"), 'g');
var CJK_QUOTE = new RegExp("([".concat(CJK, "])([`\"\u05F4])"), 'g');
var QUOTE_CJK = new RegExp("([`\"\u05F4])([".concat(CJK, "])"), 'g');
var FIX_QUOTE_ANY_QUOTE = /([`"\u05f4]+)[ ]*(.+?)[ ]*([`"\u05f4]+)/g;
var CJK_SINGLE_QUOTE_BUT_POSSESSIVE = new RegExp("([".concat(CJK, "])('[^s])"), 'g');
var SINGLE_QUOTE_CJK = new RegExp("(')([".concat(CJK, "])"), 'g');
var FIX_POSSESSIVE_SINGLE_QUOTE = new RegExp("([A-Za-z0-9".concat(CJK, "])( )('s)"), 'g');
var HASH_ANS_CJK_HASH = new RegExp("([".concat(CJK, "])(#)([").concat(CJK, "]+)(#)([").concat(CJK, "])"), 'g');
var CJK_HASH = new RegExp("([".concat(CJK, "])(#([^ ]))"), 'g');
var HASH_CJK = new RegExp("(([^ ])#)([".concat(CJK, "])"), 'g');
var CJK_OPERATOR_ANS = new RegExp("([".concat(CJK, "])([\\+\\-\\*\\/=&\\|<>])([A-Za-z0-9])"), 'g');
var ANS_OPERATOR_CJK = new RegExp("([A-Za-z0-9])([\\+\\-\\*\\/=&\\|<>])([".concat(CJK, "])"), 'g');
var FIX_SLASH_AS = /([/]) ([a-z\-_\./]+)/g;
var FIX_SLASH_AS_SLASH = /([/\.])([A-Za-z\-_\./]+) ([/])/g;
var CJK_LEFT_BRACKET = new RegExp("([".concat(CJK, "])([\\(\\[\\{<>\u201C])"), 'g');
var RIGHT_BRACKET_CJK = new RegExp("([\\)\\]\\}<>\u201D])([".concat(CJK, "])"), 'g');
var FIX_LEFT_BRACKET_ANY_RIGHT_BRACKET = /([\(\[\{<\u201c]+)[ ]*(.+?)[ ]*([\)\]\}>\u201d]+)/;
var ANS_CJK_LEFT_BRACKET_ANY_RIGHT_BRACKET = new RegExp("([A-Za-z0-9".concat(CJK, "])[ ]*([\u201C])([A-Za-z0-9").concat(CJK, "\\-_ ]+)([\u201D])"), 'g');
var LEFT_BRACKET_ANY_RIGHT_BRACKET_ANS_CJK = new RegExp("([\u201C])([A-Za-z0-9".concat(CJK, "\\-_ ]+)([\u201D])[ ]*([A-Za-z0-9").concat(CJK, "])"), 'g');
var AN_LEFT_BRACKET = /([A-Za-z0-9])([\(\[\{])/g;
var RIGHT_BRACKET_AN = /([\)\]\}])([A-Za-z0-9])/g;
var CJK_ANS = new RegExp("([".concat(CJK, "])([A-Za-z\u0370-\u03FF0-9@\\$%\\^&\\*\\-\\+\\\\=\\|/\xA1-\xFF\u2150-\u218F\u2700\u2014\u27BF])"), 'g');
var ANS_CJK = new RegExp("([A-Za-z\u0370-\u03FF0-9~\\$%\\^&\\*\\-\\+\\\\=\\|/!;:,\\.\\?\xA1-\xFF\u2150-\u218F\u2700\u2014\u27BF])([".concat(CJK, "])"), 'g');
var S_A = /(%)([A-Za-z])/g;
var MIDDLE_DOT = /([ ]*)([\u00b7\u2022\u2027])([ ]*)/g;

var Pangu = function () {
  function Pangu() {
    _classCallCheck(this, Pangu);

    this.version = '4.0.7';
  }

  _createClass(Pangu, [{
    key: "convertToFullwidth",
    value: function convertToFullwidth(symbols) {
      return symbols.replace(/~/g, 'ÔΩû').replace(/!/g, 'ÔºÅ').replace(/;/g, 'Ôºõ').replace(/:/g, 'Ôºö').replace(/,/g, 'Ôºå').replace(/\./g, '„ÄÇ').replace(/\?/g, 'Ôºü');
    }
  }, {
    key: "spacing",
    value: function spacing(text) {
      if (typeof text !== 'string') {
        console.warn("spacing(text) only accepts string but got ".concat(_typeof(text)));
        return text;
      }

      if (text.length <= 1 || !ANY_CJK.test(text)) {
        return text;
      }

      var self = this;
      var newText = text;
      newText = newText.replace(CONVERT_TO_FULLWIDTH_CJK_SYMBOLS_CJK, function (match, leftCjk, symbols, rightCjk) {
        var fullwidthSymbols = self.convertToFullwidth(symbols);
        return "".concat(leftCjk).concat(fullwidthSymbols).concat(rightCjk);
      });
      newText = newText.replace(CONVERT_TO_FULLWIDTH_CJK_SYMBOLS, function (match, cjk, symbols) {
        var fullwidthSymbols = self.convertToFullwidth(symbols);
        return "".concat(cjk).concat(fullwidthSymbols);
      });
      newText = newText.replace(DOTS_CJK, '$1 $2');
      newText = newText.replace(FIX_CJK_COLON_ANS, '$1Ôºö$2');
      newText = newText.replace(CJK_QUOTE, '$1 $2');
      newText = newText.replace(QUOTE_CJK, '$1 $2');
      newText = newText.replace(FIX_QUOTE_ANY_QUOTE, '$1$2$3');
      newText = newText.replace(CJK_SINGLE_QUOTE_BUT_POSSESSIVE, '$1 $2');
      newText = newText.replace(SINGLE_QUOTE_CJK, '$1 $2');
      newText = newText.replace(FIX_POSSESSIVE_SINGLE_QUOTE, "$1's");
      newText = newText.replace(HASH_ANS_CJK_HASH, '$1 $2$3$4 $5');
      newText = newText.replace(CJK_HASH, '$1 $2');
      newText = newText.replace(HASH_CJK, '$1 $3');
      newText = newText.replace(CJK_OPERATOR_ANS, '$1 $2 $3');
      newText = newText.replace(ANS_OPERATOR_CJK, '$1 $2 $3');
      newText = newText.replace(FIX_SLASH_AS, '$1$2');
      newText = newText.replace(FIX_SLASH_AS_SLASH, '$1$2$3');
      newText = newText.replace(CJK_LEFT_BRACKET, '$1 $2');
      newText = newText.replace(RIGHT_BRACKET_CJK, '$1 $2');
      newText = newText.replace(FIX_LEFT_BRACKET_ANY_RIGHT_BRACKET, '$1$2$3');
      newText = newText.replace(ANS_CJK_LEFT_BRACKET_ANY_RIGHT_BRACKET, '$1 $2$3$4');
      newText = newText.replace(LEFT_BRACKET_ANY_RIGHT_BRACKET_ANS_CJK, '$1$2$3 $4');
      newText = newText.replace(AN_LEFT_BRACKET, '$1 $2');
      newText = newText.replace(RIGHT_BRACKET_AN, '$1 $2');
      newText = newText.replace(CJK_ANS, '$1 $2');
      newText = newText.replace(ANS_CJK, '$1 $2');
      newText = newText.replace(S_A, '$1 $2');
      newText = newText.replace(MIDDLE_DOT, '„Éª');
      return newText;
    }
  }, {
    key: "spacingText",
    value: function spacingText(text) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
      var newText;

      try {
        newText = this.spacing(text);
      } catch (err) {
        callback(err);
        return;
      }

      callback(null, newText);
    }
  }, {
    key: "spacingTextSync",
    value: function spacingTextSync(text) {
      return this.spacing(text);
    }
  }]);

  return Pangu;
}();

var pangu = new Pangu();
module.exports = pangu;
module.exports.default = pangu;
module.exports.Pangu = Pangu;
}],
[/* 3 */ 'markdown-it', '/lib/common/utils.js', function(exports, module, __filename, __dirname, __meta) {
// Utilities
//
'use strict';


function _class(obj) { return Object.prototype.toString.call(obj); }

function isString(obj) { return _class(obj) === '[object String]'; }

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) { return false; }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }
  // control codes
  if (c >= 0x00 && c <= 0x08) { return false; }
  if (c === 0x0B) { return false; }
  if (c >= 0x0E && c <= 0x1F) { return false; }
  if (c >= 0x7F && c <= 0x9F) { return false; }
  // out of range
  if (c > 0x10FFFF) { return false; }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}


var UNESCAPE_MD_RE  = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __node_require__(4 /* './entities' */);

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ?
      parseInt(name.slice(2), 16)
    :
      parseInt(name.slice(1), 10);
    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) { return str; }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) { return str; }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) { return escaped; }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) { return true; }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = __node_require__(6 /* 'uc.micro/categories/P/regex' */);

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}


// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21/* ! */:
    case 0x22/* " */:
    case 0x23/* # */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x26/* & */:
    case 0x27/* ' */:
    case 0x28/* ( */:
    case 0x29/* ) */:
    case 0x2A/* * */:
    case 0x2B/* + */:
    case 0x2C/* , */:
    case 0x2D/* - */:
    case 0x2E/* . */:
    case 0x2F/* / */:
    case 0x3A/* : */:
    case 0x3B/* ; */:
    case 0x3C/* < */:
    case 0x3D/* = */:
    case 0x3E/* > */:
    case 0x3F/* ? */:
    case 0x40/* @ */:
    case 0x5B/* [ */:
    case 0x5C/* \ */:
    case 0x5D/* ] */:
    case 0x5E/* ^ */:
    case 0x5F/* _ */:
    case 0x60/* ` */:
    case 0x7B/* { */:
    case 0x7C/* | */:
    case 0x7D/* } */:
    case 0x7E/* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib                 = {};
exports.lib.mdurl           = __node_require__(7 /* 'mdurl' */);
exports.lib.ucmicro         = __node_require__(12 /* 'uc.micro' */);

exports.assign              = assign;
exports.isString            = isString;
exports.has                 = has;
exports.unescapeMd          = unescapeMd;
exports.unescapeAll         = unescapeAll;
exports.isValidEntityCode   = isValidEntityCode;
exports.fromCodePoint       = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml          = escapeHtml;
exports.arrayReplaceAt      = arrayReplaceAt;
exports.isSpace             = isSpace;
exports.isWhiteSpace        = isWhiteSpace;
exports.isMdAsciiPunct      = isMdAsciiPunct;
exports.isPunctChar         = isPunctChar;
exports.escapeRE            = escapeRE;
exports.normalizeReference  = normalizeReference;
}],
[/* 4 */ 'markdown-it', '/lib/common/entities.js', function(exports, module, __filename, __dirname, __meta) {
// HTML5 entities map: { name -> utf16string }
//
'use strict';

/*eslint quotes:0*/
module.exports = __node_require__(5 /* 'entities/maps/entities.json' */);
}],
[/* 5 */ 'entities', '/maps/entities.json', function(exports, module, __filename, __dirname, __meta) {
module.exports = {
  "Aacute": "√Å",
  "aacute": "√°",
  "Abreve": "ƒÇ",
  "abreve": "ƒÉ",
  "ac": "‚àæ",
  "acd": "‚àø",
  "acE": "‚àæÃ≥",
  "Acirc": "√Ç",
  "acirc": "√¢",
  "acute": "¬¥",
  "Acy": "–ê",
  "acy": "–∞",
  "AElig": "√Ü",
  "aelig": "√¶",
  "af": "‚Å°",
  "Afr": "ùîÑ",
  "afr": "ùîû",
  "Agrave": "√Ä",
  "agrave": "√†",
  "alefsym": "‚Ñµ",
  "aleph": "‚Ñµ",
  "Alpha": "Œë",
  "alpha": "Œ±",
  "Amacr": "ƒÄ",
  "amacr": "ƒÅ",
  "amalg": "‚®ø",
  "amp": "&",
  "AMP": "&",
  "andand": "‚©ï",
  "And": "‚©ì",
  "and": "‚àß",
  "andd": "‚©ú",
  "andslope": "‚©ò",
  "andv": "‚©ö",
  "ang": "‚à†",
  "ange": "‚¶§",
  "angle": "‚à†",
  "angmsdaa": "‚¶®",
  "angmsdab": "‚¶©",
  "angmsdac": "‚¶™",
  "angmsdad": "‚¶´",
  "angmsdae": "‚¶¨",
  "angmsdaf": "‚¶≠",
  "angmsdag": "‚¶Æ",
  "angmsdah": "‚¶Ø",
  "angmsd": "‚à°",
  "angrt": "‚àü",
  "angrtvb": "‚äæ",
  "angrtvbd": "‚¶ù",
  "angsph": "‚à¢",
  "angst": "√Ö",
  "angzarr": "‚çº",
  "Aogon": "ƒÑ",
  "aogon": "ƒÖ",
  "Aopf": "ùî∏",
  "aopf": "ùïí",
  "apacir": "‚©Ø",
  "ap": "‚âà",
  "apE": "‚©∞",
  "ape": "‚âä",
  "apid": "‚âã",
  "apos": "'",
  "ApplyFunction": "‚Å°",
  "approx": "‚âà",
  "approxeq": "‚âä",
  "Aring": "√Ö",
  "aring": "√•",
  "Ascr": "ùíú",
  "ascr": "ùí∂",
  "Assign": "‚âî",
  "ast": "*",
  "asymp": "‚âà",
  "asympeq": "‚âç",
  "Atilde": "√É",
  "atilde": "√£",
  "Auml": "√Ñ",
  "auml": "√§",
  "awconint": "‚à≥",
  "awint": "‚®ë",
  "backcong": "‚âå",
  "backepsilon": "œ∂",
  "backprime": "‚Äµ",
  "backsim": "‚àΩ",
  "backsimeq": "‚ãç",
  "Backslash": "‚àñ",
  "Barv": "‚´ß",
  "barvee": "‚äΩ",
  "barwed": "‚åÖ",
  "Barwed": "‚åÜ",
  "barwedge": "‚åÖ",
  "bbrk": "‚éµ",
  "bbrktbrk": "‚é∂",
  "bcong": "‚âå",
  "Bcy": "–ë",
  "bcy": "–±",
  "bdquo": "‚Äû",
  "becaus": "‚àµ",
  "because": "‚àµ",
  "Because": "‚àµ",
  "bemptyv": "‚¶∞",
  "bepsi": "œ∂",
  "bernou": "‚Ñ¨",
  "Bernoullis": "‚Ñ¨",
  "Beta": "Œí",
  "beta": "Œ≤",
  "beth": "‚Ñ∂",
  "between": "‚â¨",
  "Bfr": "ùîÖ",
  "bfr": "ùîü",
  "bigcap": "‚ãÇ",
  "bigcirc": "‚óØ",
  "bigcup": "‚ãÉ",
  "bigodot": "‚®Ä",
  "bigoplus": "‚®Å",
  "bigotimes": "‚®Ç",
  "bigsqcup": "‚®Ü",
  "bigstar": "‚òÖ",
  "bigtriangledown": "‚ñΩ",
  "bigtriangleup": "‚ñ≥",
  "biguplus": "‚®Ñ",
  "bigvee": "‚ãÅ",
  "bigwedge": "‚ãÄ",
  "bkarow": "‚§ç",
  "blacklozenge": "‚ß´",
  "blacksquare": "‚ñ™",
  "blacktriangle": "‚ñ¥",
  "blacktriangledown": "‚ñæ",
  "blacktriangleleft": "‚óÇ",
  "blacktriangleright": "‚ñ∏",
  "blank": "‚ê£",
  "blk12": "‚ñí",
  "blk14": "‚ñë",
  "blk34": "‚ñì",
  "block": "‚ñà",
  "bne": "=‚É•",
  "bnequiv": "‚â°‚É•",
  "bNot": "‚´≠",
  "bnot": "‚åê",
  "Bopf": "ùîπ",
  "bopf": "ùïì",
  "bot": "‚ä•",
  "bottom": "‚ä•",
  "bowtie": "‚ãà",
  "boxbox": "‚ßâ",
  "boxdl": "‚îê",
  "boxdL": "‚ïï",
  "boxDl": "‚ïñ",
  "boxDL": "‚ïó",
  "boxdr": "‚îå",
  "boxdR": "‚ïí",
  "boxDr": "‚ïì",
  "boxDR": "‚ïî",
  "boxh": "‚îÄ",
  "boxH": "‚ïê",
  "boxhd": "‚î¨",
  "boxHd": "‚ï§",
  "boxhD": "‚ï•",
  "boxHD": "‚ï¶",
  "boxhu": "‚î¥",
  "boxHu": "‚ïß",
  "boxhU": "‚ï®",
  "boxHU": "‚ï©",
  "boxminus": "‚äü",
  "boxplus": "‚äû",
  "boxtimes": "‚ä†",
  "boxul": "‚îò",
  "boxuL": "‚ïõ",
  "boxUl": "‚ïú",
  "boxUL": "‚ïù",
  "boxur": "‚îî",
  "boxuR": "‚ïò",
  "boxUr": "‚ïô",
  "boxUR": "‚ïö",
  "boxv": "‚îÇ",
  "boxV": "‚ïë",
  "boxvh": "‚îº",
  "boxvH": "‚ï™",
  "boxVh": "‚ï´",
  "boxVH": "‚ï¨",
  "boxvl": "‚î§",
  "boxvL": "‚ï°",
  "boxVl": "‚ï¢",
  "boxVL": "‚ï£",
  "boxvr": "‚îú",
  "boxvR": "‚ïû",
  "boxVr": "‚ïü",
  "boxVR": "‚ï†",
  "bprime": "‚Äµ",
  "breve": "Àò",
  "Breve": "Àò",
  "brvbar": "¬¶",
  "bscr": "ùí∑",
  "Bscr": "‚Ñ¨",
  "bsemi": "‚Åè",
  "bsim": "‚àΩ",
  "bsime": "‚ãç",
  "bsolb": "‚ßÖ",
  "bsol": "\\",
  "bsolhsub": "‚üà",
  "bull": "‚Ä¢",
  "bullet": "‚Ä¢",
  "bump": "‚âé",
  "bumpE": "‚™Æ",
  "bumpe": "‚âè",
  "Bumpeq": "‚âé",
  "bumpeq": "‚âè",
  "Cacute": "ƒÜ",
  "cacute": "ƒá",
  "capand": "‚©Ñ",
  "capbrcup": "‚©â",
  "capcap": "‚©ã",
  "cap": "‚à©",
  "Cap": "‚ãí",
  "capcup": "‚©á",
  "capdot": "‚©Ä",
  "CapitalDifferentialD": "‚ÖÖ",
  "caps": "‚à©Ô∏Ä",
  "caret": "‚ÅÅ",
  "caron": "Àá",
  "Cayleys": "‚Ñ≠",
  "ccaps": "‚©ç",
  "Ccaron": "ƒå",
  "ccaron": "ƒç",
  "Ccedil": "√á",
  "ccedil": "√ß",
  "Ccirc": "ƒà",
  "ccirc": "ƒâ",
  "Cconint": "‚à∞",
  "ccups": "‚©å",
  "ccupssm": "‚©ê",
  "Cdot": "ƒä",
  "cdot": "ƒã",
  "cedil": "¬∏",
  "Cedilla": "¬∏",
  "cemptyv": "‚¶≤",
  "cent": "¬¢",
  "centerdot": "¬∑",
  "CenterDot": "¬∑",
  "cfr": "ùî†",
  "Cfr": "‚Ñ≠",
  "CHcy": "–ß",
  "chcy": "—á",
  "check": "‚úì",
  "checkmark": "‚úì",
  "Chi": "Œß",
  "chi": "œá",
  "circ": "ÀÜ",
  "circeq": "‚âó",
  "circlearrowleft": "‚Ü∫",
  "circlearrowright": "‚Üª",
  "circledast": "‚äõ",
  "circledcirc": "‚äö",
  "circleddash": "‚äù",
  "CircleDot": "‚äô",
  "circledR": "¬Æ",
  "circledS": "‚ìà",
  "CircleMinus": "‚äñ",
  "CirclePlus": "‚äï",
  "CircleTimes": "‚äó",
  "cir": "‚óã",
  "cirE": "‚ßÉ",
  "cire": "‚âó",
  "cirfnint": "‚®ê",
  "cirmid": "‚´Ø",
  "cirscir": "‚ßÇ",
  "ClockwiseContourIntegral": "‚à≤",
  "CloseCurlyDoubleQuote": "‚Äù",
  "CloseCurlyQuote": "‚Äô",
  "clubs": "‚ô£",
  "clubsuit": "‚ô£",
  "colon": ":",
  "Colon": "‚à∑",
  "Colone": "‚©¥",
  "colone": "‚âî",
  "coloneq": "‚âî",
  "comma": ",",
  "commat": "@",
  "comp": "‚àÅ",
  "compfn": "‚àò",
  "complement": "‚àÅ",
  "complexes": "‚ÑÇ",
  "cong": "‚âÖ",
  "congdot": "‚©≠",
  "Congruent": "‚â°",
  "conint": "‚àÆ",
  "Conint": "‚àØ",
  "ContourIntegral": "‚àÆ",
  "copf": "ùïî",
  "Copf": "‚ÑÇ",
  "coprod": "‚àê",
  "Coproduct": "‚àê",
  "copy": "¬©",
  "COPY": "¬©",
  "copysr": "‚Ñó",
  "CounterClockwiseContourIntegral": "‚à≥",
  "crarr": "‚Üµ",
  "cross": "‚úó",
  "Cross": "‚®Ø",
  "Cscr": "ùíû",
  "cscr": "ùí∏",
  "csub": "‚´è",
  "csube": "‚´ë",
  "csup": "‚´ê",
  "csupe": "‚´í",
  "ctdot": "‚ãØ",
  "cudarrl": "‚§∏",
  "cudarrr": "‚§µ",
  "cuepr": "‚ãû",
  "cuesc": "‚ãü",
  "cularr": "‚Ü∂",
  "cularrp": "‚§Ω",
  "cupbrcap": "‚©à",
  "cupcap": "‚©Ü",
  "CupCap": "‚âç",
  "cup": "‚à™",
  "Cup": "‚ãì",
  "cupcup": "‚©ä",
  "cupdot": "‚äç",
  "cupor": "‚©Ö",
  "cups": "‚à™Ô∏Ä",
  "curarr": "‚Ü∑",
  "curarrm": "‚§º",
  "curlyeqprec": "‚ãû",
  "curlyeqsucc": "‚ãü",
  "curlyvee": "‚ãé",
  "curlywedge": "‚ãè",
  "curren": "¬§",
  "curvearrowleft": "‚Ü∂",
  "curvearrowright": "‚Ü∑",
  "cuvee": "‚ãé",
  "cuwed": "‚ãè",
  "cwconint": "‚à≤",
  "cwint": "‚à±",
  "cylcty": "‚å≠",
  "dagger": "‚Ä†",
  "Dagger": "‚Ä°",
  "daleth": "‚Ñ∏",
  "darr": "‚Üì",
  "Darr": "‚Ü°",
  "dArr": "‚áì",
  "dash": "‚Äê",
  "Dashv": "‚´§",
  "dashv": "‚ä£",
  "dbkarow": "‚§è",
  "dblac": "Àù",
  "Dcaron": "ƒé",
  "dcaron": "ƒè",
  "Dcy": "–î",
  "dcy": "–¥",
  "ddagger": "‚Ä°",
  "ddarr": "‚áä",
  "DD": "‚ÖÖ",
  "dd": "‚ÖÜ",
  "DDotrahd": "‚§ë",
  "ddotseq": "‚©∑",
  "deg": "¬∞",
  "Del": "‚àá",
  "Delta": "Œî",
  "delta": "Œ¥",
  "demptyv": "‚¶±",
  "dfisht": "‚•ø",
  "Dfr": "ùîá",
  "dfr": "ùî°",
  "dHar": "‚••",
  "dharl": "‚áÉ",
  "dharr": "‚áÇ",
  "DiacriticalAcute": "¬¥",
  "DiacriticalDot": "Àô",
  "DiacriticalDoubleAcute": "Àù",
  "DiacriticalGrave": "`",
  "DiacriticalTilde": "Àú",
  "diam": "‚ãÑ",
  "diamond": "‚ãÑ",
  "Diamond": "‚ãÑ",
  "diamondsuit": "‚ô¶",
  "diams": "‚ô¶",
  "die": "¬®",
  "DifferentialD": "‚ÖÜ",
  "digamma": "œù",
  "disin": "‚ã≤",
  "div": "√∑",
  "divide": "√∑",
  "divideontimes": "‚ãá",
  "divonx": "‚ãá",
  "DJcy": "–Ç",
  "djcy": "—í",
  "dlcorn": "‚åû",
  "dlcrop": "‚åç",
  "dollar": "$",
  "Dopf": "ùîª",
  "dopf": "ùïï",
  "Dot": "¬®",
  "dot": "Àô",
  "DotDot": "‚Éú",
  "doteq": "‚âê",
  "doteqdot": "‚âë",
  "DotEqual": "‚âê",
  "dotminus": "‚à∏",
  "dotplus": "‚àî",
  "dotsquare": "‚ä°",
  "doublebarwedge": "‚åÜ",
  "DoubleContourIntegral": "‚àØ",
  "DoubleDot": "¬®",
  "DoubleDownArrow": "‚áì",
  "DoubleLeftArrow": "‚áê",
  "DoubleLeftRightArrow": "‚áî",
  "DoubleLeftTee": "‚´§",
  "DoubleLongLeftArrow": "‚ü∏",
  "DoubleLongLeftRightArrow": "‚ü∫",
  "DoubleLongRightArrow": "‚üπ",
  "DoubleRightArrow": "‚áí",
  "DoubleRightTee": "‚ä®",
  "DoubleUpArrow": "‚áë",
  "DoubleUpDownArrow": "‚áï",
  "DoubleVerticalBar": "‚à•",
  "DownArrowBar": "‚§ì",
  "downarrow": "‚Üì",
  "DownArrow": "‚Üì",
  "Downarrow": "‚áì",
  "DownArrowUpArrow": "‚áµ",
  "DownBreve": "Ãë",
  "downdownarrows": "‚áä",
  "downharpoonleft": "‚áÉ",
  "downharpoonright": "‚áÇ",
  "DownLeftRightVector": "‚•ê",
  "DownLeftTeeVector": "‚•û",
  "DownLeftVectorBar": "‚•ñ",
  "DownLeftVector": "‚ÜΩ",
  "DownRightTeeVector": "‚•ü",
  "DownRightVectorBar": "‚•ó",
  "DownRightVector": "‚áÅ",
  "DownTeeArrow": "‚Üß",
  "DownTee": "‚ä§",
  "drbkarow": "‚§ê",
  "drcorn": "‚åü",
  "drcrop": "‚åå",
  "Dscr": "ùíü",
  "dscr": "ùíπ",
  "DScy": "–Ö",
  "dscy": "—ï",
  "dsol": "‚ß∂",
  "Dstrok": "ƒê",
  "dstrok": "ƒë",
  "dtdot": "‚ã±",
  "dtri": "‚ñø",
  "dtrif": "‚ñæ",
  "duarr": "‚áµ",
  "duhar": "‚•Ø",
  "dwangle": "‚¶¶",
  "DZcy": "–è",
  "dzcy": "—ü",
  "dzigrarr": "‚üø",
  "Eacute": "√â",
  "eacute": "√©",
  "easter": "‚©Æ",
  "Ecaron": "ƒö",
  "ecaron": "ƒõ",
  "Ecirc": "√ä",
  "ecirc": "√™",
  "ecir": "‚âñ",
  "ecolon": "‚âï",
  "Ecy": "–≠",
  "ecy": "—ç",
  "eDDot": "‚©∑",
  "Edot": "ƒñ",
  "edot": "ƒó",
  "eDot": "‚âë",
  "ee": "‚Öá",
  "efDot": "‚âí",
  "Efr": "ùîà",
  "efr": "ùî¢",
  "eg": "‚™ö",
  "Egrave": "√à",
  "egrave": "√®",
  "egs": "‚™ñ",
  "egsdot": "‚™ò",
  "el": "‚™ô",
  "Element": "‚àà",
  "elinters": "‚èß",
  "ell": "‚Ñì",
  "els": "‚™ï",
  "elsdot": "‚™ó",
  "Emacr": "ƒí",
  "emacr": "ƒì",
  "empty": "‚àÖ",
  "emptyset": "‚àÖ",
  "EmptySmallSquare": "‚óª",
  "emptyv": "‚àÖ",
  "EmptyVerySmallSquare": "‚ñ´",
  "emsp13": "‚ÄÑ",
  "emsp14": "‚ÄÖ",
  "emsp": "‚ÄÉ",
  "ENG": "≈ä",
  "eng": "≈ã",
  "ensp": "‚ÄÇ",
  "Eogon": "ƒò",
  "eogon": "ƒô",
  "Eopf": "ùîº",
  "eopf": "ùïñ",
  "epar": "‚ãï",
  "eparsl": "‚ß£",
  "eplus": "‚©±",
  "epsi": "Œµ",
  "Epsilon": "Œï",
  "epsilon": "Œµ",
  "epsiv": "œµ",
  "eqcirc": "‚âñ",
  "eqcolon": "‚âï",
  "eqsim": "‚âÇ",
  "eqslantgtr": "‚™ñ",
  "eqslantless": "‚™ï",
  "Equal": "‚©µ",
  "equals": "=",
  "EqualTilde": "‚âÇ",
  "equest": "‚âü",
  "Equilibrium": "‚áå",
  "equiv": "‚â°",
  "equivDD": "‚©∏",
  "eqvparsl": "‚ß•",
  "erarr": "‚•±",
  "erDot": "‚âì",
  "escr": "‚ÑØ",
  "Escr": "‚Ñ∞",
  "esdot": "‚âê",
  "Esim": "‚©≥",
  "esim": "‚âÇ",
  "Eta": "Œó",
  "eta": "Œ∑",
  "ETH": "√ê",
  "eth": "√∞",
  "Euml": "√ã",
  "euml": "√´",
  "euro": "‚Ç¨",
  "excl": "!",
  "exist": "‚àÉ",
  "Exists": "‚àÉ",
  "expectation": "‚Ñ∞",
  "exponentiale": "‚Öá",
  "ExponentialE": "‚Öá",
  "fallingdotseq": "‚âí",
  "Fcy": "–§",
  "fcy": "—Ñ",
  "female": "‚ôÄ",
  "ffilig": "Ô¨É",
  "fflig": "Ô¨Ä",
  "ffllig": "Ô¨Ñ",
  "Ffr": "ùîâ",
  "ffr": "ùî£",
  "filig": "Ô¨Å",
  "FilledSmallSquare": "‚óº",
  "FilledVerySmallSquare": "‚ñ™",
  "fjlig": "fj",
  "flat": "‚ô≠",
  "fllig": "Ô¨Ç",
  "fltns": "‚ñ±",
  "fnof": "∆í",
  "Fopf": "ùîΩ",
  "fopf": "ùïó",
  "forall": "‚àÄ",
  "ForAll": "‚àÄ",
  "fork": "‚ãî",
  "forkv": "‚´ô",
  "Fouriertrf": "‚Ñ±",
  "fpartint": "‚®ç",
  "frac12": "¬Ω",
  "frac13": "‚Öì",
  "frac14": "¬º",
  "frac15": "‚Öï",
  "frac16": "‚Öô",
  "frac18": "‚Öõ",
  "frac23": "‚Öî",
  "frac25": "‚Öñ",
  "frac34": "¬æ",
  "frac35": "‚Öó",
  "frac38": "‚Öú",
  "frac45": "‚Öò",
  "frac56": "‚Öö",
  "frac58": "‚Öù",
  "frac78": "‚Öû",
  "frasl": "‚ÅÑ",
  "frown": "‚å¢",
  "fscr": "ùíª",
  "Fscr": "‚Ñ±",
  "gacute": "«µ",
  "Gamma": "Œì",
  "gamma": "Œ≥",
  "Gammad": "œú",
  "gammad": "œù",
  "gap": "‚™Ü",
  "Gbreve": "ƒû",
  "gbreve": "ƒü",
  "Gcedil": "ƒ¢",
  "Gcirc": "ƒú",
  "gcirc": "ƒù",
  "Gcy": "–ì",
  "gcy": "–≥",
  "Gdot": "ƒ†",
  "gdot": "ƒ°",
  "ge": "‚â•",
  "gE": "‚âß",
  "gEl": "‚™å",
  "gel": "‚ãõ",
  "geq": "‚â•",
  "geqq": "‚âß",
  "geqslant": "‚©æ",
  "gescc": "‚™©",
  "ges": "‚©æ",
  "gesdot": "‚™Ä",
  "gesdoto": "‚™Ç",
  "gesdotol": "‚™Ñ",
  "gesl": "‚ãõÔ∏Ä",
  "gesles": "‚™î",
  "Gfr": "ùîä",
  "gfr": "ùî§",
  "gg": "‚â´",
  "Gg": "‚ãô",
  "ggg": "‚ãô",
  "gimel": "‚Ñ∑",
  "GJcy": "–É",
  "gjcy": "—ì",
  "gla": "‚™•",
  "gl": "‚â∑",
  "glE": "‚™í",
  "glj": "‚™§",
  "gnap": "‚™ä",
  "gnapprox": "‚™ä",
  "gne": "‚™à",
  "gnE": "‚â©",
  "gneq": "‚™à",
  "gneqq": "‚â©",
  "gnsim": "‚ãß",
  "Gopf": "ùîæ",
  "gopf": "ùïò",
  "grave": "`",
  "GreaterEqual": "‚â•",
  "GreaterEqualLess": "‚ãõ",
  "GreaterFullEqual": "‚âß",
  "GreaterGreater": "‚™¢",
  "GreaterLess": "‚â∑",
  "GreaterSlantEqual": "‚©æ",
  "GreaterTilde": "‚â≥",
  "Gscr": "ùí¢",
  "gscr": "‚Ñä",
  "gsim": "‚â≥",
  "gsime": "‚™é",
  "gsiml": "‚™ê",
  "gtcc": "‚™ß",
  "gtcir": "‚©∫",
  "gt": ">",
  "GT": ">",
  "Gt": "‚â´",
  "gtdot": "‚ãó",
  "gtlPar": "‚¶ï",
  "gtquest": "‚©º",
  "gtrapprox": "‚™Ü",
  "gtrarr": "‚•∏",
  "gtrdot": "‚ãó",
  "gtreqless": "‚ãõ",
  "gtreqqless": "‚™å",
  "gtrless": "‚â∑",
  "gtrsim": "‚â≥",
  "gvertneqq": "‚â©Ô∏Ä",
  "gvnE": "‚â©Ô∏Ä",
  "Hacek": "Àá",
  "hairsp": "‚Ää",
  "half": "¬Ω",
  "hamilt": "‚Ñã",
  "HARDcy": "–™",
  "hardcy": "—ä",
  "harrcir": "‚•à",
  "harr": "‚Üî",
  "hArr": "‚áî",
  "harrw": "‚Ü≠",
  "Hat": "^",
  "hbar": "‚Ñè",
  "Hcirc": "ƒ§",
  "hcirc": "ƒ•",
  "hearts": "‚ô•",
  "heartsuit": "‚ô•",
  "hellip": "‚Ä¶",
  "hercon": "‚äπ",
  "hfr": "ùî•",
  "Hfr": "‚Ñå",
  "HilbertSpace": "‚Ñã",
  "hksearow": "‚§•",
  "hkswarow": "‚§¶",
  "hoarr": "‚áø",
  "homtht": "‚àª",
  "hookleftarrow": "‚Ü©",
  "hookrightarrow": "‚Ü™",
  "hopf": "ùïô",
  "Hopf": "‚Ñç",
  "horbar": "‚Äï",
  "HorizontalLine": "‚îÄ",
  "hscr": "ùíΩ",
  "Hscr": "‚Ñã",
  "hslash": "‚Ñè",
  "Hstrok": "ƒ¶",
  "hstrok": "ƒß",
  "HumpDownHump": "‚âé",
  "HumpEqual": "‚âè",
  "hybull": "‚ÅÉ",
  "hyphen": "‚Äê",
  "Iacute": "√ç",
  "iacute": "√≠",
  "ic": "‚Å£",
  "Icirc": "√é",
  "icirc": "√Æ",
  "Icy": "–ò",
  "icy": "–∏",
  "Idot": "ƒ∞",
  "IEcy": "–ï",
  "iecy": "–µ",
  "iexcl": "¬°",
  "iff": "‚áî",
  "ifr": "ùî¶",
  "Ifr": "‚Ñë",
  "Igrave": "√å",
  "igrave": "√¨",
  "ii": "‚Öà",
  "iiiint": "‚®å",
  "iiint": "‚à≠",
  "iinfin": "‚ßú",
  "iiota": "‚Ñ©",
  "IJlig": "ƒ≤",
  "ijlig": "ƒ≥",
  "Imacr": "ƒ™",
  "imacr": "ƒ´",
  "image": "‚Ñë",
  "ImaginaryI": "‚Öà",
  "imagline": "‚Ñê",
  "imagpart": "‚Ñë",
  "imath": "ƒ±",
  "Im": "‚Ñë",
  "imof": "‚ä∑",
  "imped": "∆µ",
  "Implies": "‚áí",
  "incare": "‚ÑÖ",
  "in": "‚àà",
  "infin": "‚àû",
  "infintie": "‚ßù",
  "inodot": "ƒ±",
  "intcal": "‚ä∫",
  "int": "‚à´",
  "Int": "‚à¨",
  "integers": "‚Ñ§",
  "Integral": "‚à´",
  "intercal": "‚ä∫",
  "Intersection": "‚ãÇ",
  "intlarhk": "‚®ó",
  "intprod": "‚®º",
  "InvisibleComma": "‚Å£",
  "InvisibleTimes": "‚Å¢",
  "IOcy": "–Å",
  "iocy": "—ë",
  "Iogon": "ƒÆ",
  "iogon": "ƒØ",
  "Iopf": "ùïÄ",
  "iopf": "ùïö",
  "Iota": "Œô",
  "iota": "Œπ",
  "iprod": "‚®º",
  "iquest": "¬ø",
  "iscr": "ùíæ",
  "Iscr": "‚Ñê",
  "isin": "‚àà",
  "isindot": "‚ãµ",
  "isinE": "‚ãπ",
  "isins": "‚ã¥",
  "isinsv": "‚ã≥",
  "isinv": "‚àà",
  "it": "‚Å¢",
  "Itilde": "ƒ®",
  "itilde": "ƒ©",
  "Iukcy": "–Ü",
  "iukcy": "—ñ",
  "Iuml": "√è",
  "iuml": "√Ø",
  "Jcirc": "ƒ¥",
  "jcirc": "ƒµ",
  "Jcy": "–ô",
  "jcy": "–π",
  "Jfr": "ùîç",
  "jfr": "ùîß",
  "jmath": "»∑",
  "Jopf": "ùïÅ",
  "jopf": "ùïõ",
  "Jscr": "ùí•",
  "jscr": "ùíø",
  "Jsercy": "–à",
  "jsercy": "—ò",
  "Jukcy": "–Ñ",
  "jukcy": "—î",
  "Kappa": "Œö",
  "kappa": "Œ∫",
  "kappav": "œ∞",
  "Kcedil": "ƒ∂",
  "kcedil": "ƒ∑",
  "Kcy": "–ö",
  "kcy": "–∫",
  "Kfr": "ùîé",
  "kfr": "ùî®",
  "kgreen": "ƒ∏",
  "KHcy": "–•",
  "khcy": "—Ö",
  "KJcy": "–å",
  "kjcy": "—ú",
  "Kopf": "ùïÇ",
  "kopf": "ùïú",
  "Kscr": "ùí¶",
  "kscr": "ùìÄ",
  "lAarr": "‚áö",
  "Lacute": "ƒπ",
  "lacute": "ƒ∫",
  "laemptyv": "‚¶¥",
  "lagran": "‚Ñí",
  "Lambda": "Œõ",
  "lambda": "Œª",
  "lang": "‚ü®",
  "Lang": "‚ü™",
  "langd": "‚¶ë",
  "langle": "‚ü®",
  "lap": "‚™Ö",
  "Laplacetrf": "‚Ñí",
  "laquo": "¬´",
  "larrb": "‚á§",
  "larrbfs": "‚§ü",
  "larr": "‚Üê",
  "Larr": "‚Üû",
  "lArr": "‚áê",
  "larrfs": "‚§ù",
  "larrhk": "‚Ü©",
  "larrlp": "‚Ü´",
  "larrpl": "‚§π",
  "larrsim": "‚•≥",
  "larrtl": "‚Ü¢",
  "latail": "‚§ô",
  "lAtail": "‚§õ",
  "lat": "‚™´",
  "late": "‚™≠",
  "lates": "‚™≠Ô∏Ä",
  "lbarr": "‚§å",
  "lBarr": "‚§é",
  "lbbrk": "‚ù≤",
  "lbrace": "{",
  "lbrack": "[",
  "lbrke": "‚¶ã",
  "lbrksld": "‚¶è",
  "lbrkslu": "‚¶ç",
  "Lcaron": "ƒΩ",
  "lcaron": "ƒæ",
  "Lcedil": "ƒª",
  "lcedil": "ƒº",
  "lceil": "‚åà",
  "lcub": "{",
  "Lcy": "–õ",
  "lcy": "–ª",
  "ldca": "‚§∂",
  "ldquo": "‚Äú",
  "ldquor": "‚Äû",
  "ldrdhar": "‚•ß",
  "ldrushar": "‚•ã",
  "ldsh": "‚Ü≤",
  "le": "‚â§",
  "lE": "‚â¶",
  "LeftAngleBracket": "‚ü®",
  "LeftArrowBar": "‚á§",
  "leftarrow": "‚Üê",
  "LeftArrow": "‚Üê",
  "Leftarrow": "‚áê",
  "LeftArrowRightArrow": "‚áÜ",
  "leftarrowtail": "‚Ü¢",
  "LeftCeiling": "‚åà",
  "LeftDoubleBracket": "‚ü¶",
  "LeftDownTeeVector": "‚•°",
  "LeftDownVectorBar": "‚•ô",
  "LeftDownVector": "‚áÉ",
  "LeftFloor": "‚åä",
  "leftharpoondown": "‚ÜΩ",
  "leftharpoonup": "‚Üº",
  "leftleftarrows": "‚áá",
  "leftrightarrow": "‚Üî",
  "LeftRightArrow": "‚Üî",
  "Leftrightarrow": "‚áî",
  "leftrightarrows": "‚áÜ",
  "leftrightharpoons": "‚áã",
  "leftrightsquigarrow": "‚Ü≠",
  "LeftRightVector": "‚•é",
  "LeftTeeArrow": "‚Ü§",
  "LeftTee": "‚ä£",
  "LeftTeeVector": "‚•ö",
  "leftthreetimes": "‚ãã",
  "LeftTriangleBar": "‚ßè",
  "LeftTriangle": "‚ä≤",
  "LeftTriangleEqual": "‚ä¥",
  "LeftUpDownVector": "‚•ë",
  "LeftUpTeeVector": "‚•†",
  "LeftUpVectorBar": "‚•ò",
  "LeftUpVector": "‚Üø",
  "LeftVectorBar": "‚•í",
  "LeftVector": "‚Üº",
  "lEg": "‚™ã",
  "leg": "‚ãö",
  "leq": "‚â§",
  "leqq": "‚â¶",
  "leqslant": "‚©Ω",
  "lescc": "‚™®",
  "les": "‚©Ω",
  "lesdot": "‚©ø",
  "lesdoto": "‚™Å",
  "lesdotor": "‚™É",
  "lesg": "‚ãöÔ∏Ä",
  "lesges": "‚™ì",
  "lessapprox": "‚™Ö",
  "lessdot": "‚ãñ",
  "lesseqgtr": "‚ãö",
  "lesseqqgtr": "‚™ã",
  "LessEqualGreater": "‚ãö",
  "LessFullEqual": "‚â¶",
  "LessGreater": "‚â∂",
  "lessgtr": "‚â∂",
  "LessLess": "‚™°",
  "lesssim": "‚â≤",
  "LessSlantEqual": "‚©Ω",
  "LessTilde": "‚â≤",
  "lfisht": "‚•º",
  "lfloor": "‚åä",
  "Lfr": "ùîè",
  "lfr": "ùî©",
  "lg": "‚â∂",
  "lgE": "‚™ë",
  "lHar": "‚•¢",
  "lhard": "‚ÜΩ",
  "lharu": "‚Üº",
  "lharul": "‚•™",
  "lhblk": "‚ñÑ",
  "LJcy": "–â",
  "ljcy": "—ô",
  "llarr": "‚áá",
  "ll": "‚â™",
  "Ll": "‚ãò",
  "llcorner": "‚åû",
  "Lleftarrow": "‚áö",
  "llhard": "‚•´",
  "lltri": "‚ó∫",
  "Lmidot": "ƒø",
  "lmidot": "≈Ä",
  "lmoustache": "‚é∞",
  "lmoust": "‚é∞",
  "lnap": "‚™â",
  "lnapprox": "‚™â",
  "lne": "‚™á",
  "lnE": "‚â®",
  "lneq": "‚™á",
  "lneqq": "‚â®",
  "lnsim": "‚ã¶",
  "loang": "‚ü¨",
  "loarr": "‚áΩ",
  "lobrk": "‚ü¶",
  "longleftarrow": "‚üµ",
  "LongLeftArrow": "‚üµ",
  "Longleftarrow": "‚ü∏",
  "longleftrightarrow": "‚ü∑",
  "LongLeftRightArrow": "‚ü∑",
  "Longleftrightarrow": "‚ü∫",
  "longmapsto": "‚üº",
  "longrightarrow": "‚ü∂",
  "LongRightArrow": "‚ü∂",
  "Longrightarrow": "‚üπ",
  "looparrowleft": "‚Ü´",
  "looparrowright": "‚Ü¨",
  "lopar": "‚¶Ö",
  "Lopf": "ùïÉ",
  "lopf": "ùïù",
  "loplus": "‚®≠",
  "lotimes": "‚®¥",
  "lowast": "‚àó",
  "lowbar": "_",
  "LowerLeftArrow": "‚Üô",
  "LowerRightArrow": "‚Üò",
  "loz": "‚óä",
  "lozenge": "‚óä",
  "lozf": "‚ß´",
  "lpar": "(",
  "lparlt": "‚¶ì",
  "lrarr": "‚áÜ",
  "lrcorner": "‚åü",
  "lrhar": "‚áã",
  "lrhard": "‚•≠",
  "lrm": "‚Äé",
  "lrtri": "‚äø",
  "lsaquo": "‚Äπ",
  "lscr": "ùìÅ",
  "Lscr": "‚Ñí",
  "lsh": "‚Ü∞",
  "Lsh": "‚Ü∞",
  "lsim": "‚â≤",
  "lsime": "‚™ç",
  "lsimg": "‚™è",
  "lsqb": "[",
  "lsquo": "‚Äò",
  "lsquor": "‚Äö",
  "Lstrok": "≈Å",
  "lstrok": "≈Ç",
  "ltcc": "‚™¶",
  "ltcir": "‚©π",
  "lt": "<",
  "LT": "<",
  "Lt": "‚â™",
  "ltdot": "‚ãñ",
  "lthree": "‚ãã",
  "ltimes": "‚ãâ",
  "ltlarr": "‚•∂",
  "ltquest": "‚©ª",
  "ltri": "‚óÉ",
  "ltrie": "‚ä¥",
  "ltrif": "‚óÇ",
  "ltrPar": "‚¶ñ",
  "lurdshar": "‚•ä",
  "luruhar": "‚•¶",
  "lvertneqq": "‚â®Ô∏Ä",
  "lvnE": "‚â®Ô∏Ä",
  "macr": "¬Ø",
  "male": "‚ôÇ",
  "malt": "‚ú†",
  "maltese": "‚ú†",
  "Map": "‚§Ö",
  "map": "‚Ü¶",
  "mapsto": "‚Ü¶",
  "mapstodown": "‚Üß",
  "mapstoleft": "‚Ü§",
  "mapstoup": "‚Ü•",
  "marker": "‚ñÆ",
  "mcomma": "‚®©",
  "Mcy": "–ú",
  "mcy": "–º",
  "mdash": "‚Äî",
  "mDDot": "‚à∫",
  "measuredangle": "‚à°",
  "MediumSpace": "‚Åü",
  "Mellintrf": "‚Ñ≥",
  "Mfr": "ùîê",
  "mfr": "ùî™",
  "mho": "‚Ñß",
  "micro": "¬µ",
  "midast": "*",
  "midcir": "‚´∞",
  "mid": "‚à£",
  "middot": "¬∑",
  "minusb": "‚äü",
  "minus": "‚àí",
  "minusd": "‚à∏",
  "minusdu": "‚®™",
  "MinusPlus": "‚àì",
  "mlcp": "‚´õ",
  "mldr": "‚Ä¶",
  "mnplus": "‚àì",
  "models": "‚äß",
  "Mopf": "ùïÑ",
  "mopf": "ùïû",
  "mp": "‚àì",
  "mscr": "ùìÇ",
  "Mscr": "‚Ñ≥",
  "mstpos": "‚àæ",
  "Mu": "Œú",
  "mu": "Œº",
  "multimap": "‚ä∏",
  "mumap": "‚ä∏",
  "nabla": "‚àá",
  "Nacute": "≈É",
  "nacute": "≈Ñ",
  "nang": "‚à†‚Éí",
  "nap": "‚ââ",
  "napE": "‚©∞Ã∏",
  "napid": "‚âãÃ∏",
  "napos": "≈â",
  "napprox": "‚ââ",
  "natural": "‚ôÆ",
  "naturals": "‚Ñï",
  "natur": "‚ôÆ",
  "nbsp": "¬†",
  "nbump": "‚âéÃ∏",
  "nbumpe": "‚âèÃ∏",
  "ncap": "‚©É",
  "Ncaron": "≈á",
  "ncaron": "≈à",
  "Ncedil": "≈Ö",
  "ncedil": "≈Ü",
  "ncong": "‚âá",
  "ncongdot": "‚©≠Ã∏",
  "ncup": "‚©Ç",
  "Ncy": "–ù",
  "ncy": "–Ω",
  "ndash": "‚Äì",
  "nearhk": "‚§§",
  "nearr": "‚Üó",
  "neArr": "‚áó",
  "nearrow": "‚Üó",
  "ne": "‚â†",
  "nedot": "‚âêÃ∏",
  "NegativeMediumSpace": "‚Äã",
  "NegativeThickSpace": "‚Äã",
  "NegativeThinSpace": "‚Äã",
  "NegativeVeryThinSpace": "‚Äã",
  "nequiv": "‚â¢",
  "nesear": "‚§®",
  "nesim": "‚âÇÃ∏",
  "NestedGreaterGreater": "‚â´",
  "NestedLessLess": "‚â™",
  "NewLine": "\n",
  "nexist": "‚àÑ",
  "nexists": "‚àÑ",
  "Nfr": "ùîë",
  "nfr": "ùî´",
  "ngE": "‚âßÃ∏",
  "nge": "‚â±",
  "ngeq": "‚â±",
  "ngeqq": "‚âßÃ∏",
  "ngeqslant": "‚©æÃ∏",
  "nges": "‚©æÃ∏",
  "nGg": "‚ãôÃ∏",
  "ngsim": "‚âµ",
  "nGt": "‚â´‚Éí",
  "ngt": "‚âØ",
  "ngtr": "‚âØ",
  "nGtv": "‚â´Ã∏",
  "nharr": "‚ÜÆ",
  "nhArr": "‚áé",
  "nhpar": "‚´≤",
  "ni": "‚àã",
  "nis": "‚ãº",
  "nisd": "‚ã∫",
  "niv": "‚àã",
  "NJcy": "–ä",
  "njcy": "—ö",
  "nlarr": "‚Üö",
  "nlArr": "‚áç",
  "nldr": "‚Ä•",
  "nlE": "‚â¶Ã∏",
  "nle": "‚â∞",
  "nleftarrow": "‚Üö",
  "nLeftarrow": "‚áç",
  "nleftrightarrow": "‚ÜÆ",
  "nLeftrightarrow": "‚áé",
  "nleq": "‚â∞",
  "nleqq": "‚â¶Ã∏",
  "nleqslant": "‚©ΩÃ∏",
  "nles": "‚©ΩÃ∏",
  "nless": "‚âÆ",
  "nLl": "‚ãòÃ∏",
  "nlsim": "‚â¥",
  "nLt": "‚â™‚Éí",
  "nlt": "‚âÆ",
  "nltri": "‚ã™",
  "nltrie": "‚ã¨",
  "nLtv": "‚â™Ã∏",
  "nmid": "‚à§",
  "NoBreak": "‚Å†",
  "NonBreakingSpace": "¬†",
  "nopf": "ùïü",
  "Nopf": "‚Ñï",
  "Not": "‚´¨",
  "not": "¬¨",
  "NotCongruent": "‚â¢",
  "NotCupCap": "‚â≠",
  "NotDoubleVerticalBar": "‚à¶",
  "NotElement": "‚àâ",
  "NotEqual": "‚â†",
  "NotEqualTilde": "‚âÇÃ∏",
  "NotExists": "‚àÑ",
  "NotGreater": "‚âØ",
  "NotGreaterEqual": "‚â±",
  "NotGreaterFullEqual": "‚âßÃ∏",
  "NotGreaterGreater": "‚â´Ã∏",
  "NotGreaterLess": "‚âπ",
  "NotGreaterSlantEqual": "‚©æÃ∏",
  "NotGreaterTilde": "‚âµ",
  "NotHumpDownHump": "‚âéÃ∏",
  "NotHumpEqual": "‚âèÃ∏",
  "notin": "‚àâ",
  "notindot": "‚ãµÃ∏",
  "notinE": "‚ãπÃ∏",
  "notinva": "‚àâ",
  "notinvb": "‚ã∑",
  "notinvc": "‚ã∂",
  "NotLeftTriangleBar": "‚ßèÃ∏",
  "NotLeftTriangle": "‚ã™",
  "NotLeftTriangleEqual": "‚ã¨",
  "NotLess": "‚âÆ",
  "NotLessEqual": "‚â∞",
  "NotLessGreater": "‚â∏",
  "NotLessLess": "‚â™Ã∏",
  "NotLessSlantEqual": "‚©ΩÃ∏",
  "NotLessTilde": "‚â¥",
  "NotNestedGreaterGreater": "‚™¢Ã∏",
  "NotNestedLessLess": "‚™°Ã∏",
  "notni": "‚àå",
  "notniva": "‚àå",
  "notnivb": "‚ãæ",
  "notnivc": "‚ãΩ",
  "NotPrecedes": "‚äÄ",
  "NotPrecedesEqual": "‚™ØÃ∏",
  "NotPrecedesSlantEqual": "‚ã†",
  "NotReverseElement": "‚àå",
  "NotRightTriangleBar": "‚ßêÃ∏",
  "NotRightTriangle": "‚ã´",
  "NotRightTriangleEqual": "‚ã≠",
  "NotSquareSubset": "‚äèÃ∏",
  "NotSquareSubsetEqual": "‚ã¢",
  "NotSquareSuperset": "‚äêÃ∏",
  "NotSquareSupersetEqual": "‚ã£",
  "NotSubset": "‚äÇ‚Éí",
  "NotSubsetEqual": "‚äà",
  "NotSucceeds": "‚äÅ",
  "NotSucceedsEqual": "‚™∞Ã∏",
  "NotSucceedsSlantEqual": "‚ã°",
  "NotSucceedsTilde": "‚âøÃ∏",
  "NotSuperset": "‚äÉ‚Éí",
  "NotSupersetEqual": "‚äâ",
  "NotTilde": "‚âÅ",
  "NotTildeEqual": "‚âÑ",
  "NotTildeFullEqual": "‚âá",
  "NotTildeTilde": "‚ââ",
  "NotVerticalBar": "‚à§",
  "nparallel": "‚à¶",
  "npar": "‚à¶",
  "nparsl": "‚´Ω‚É•",
  "npart": "‚àÇÃ∏",
  "npolint": "‚®î",
  "npr": "‚äÄ",
  "nprcue": "‚ã†",
  "nprec": "‚äÄ",
  "npreceq": "‚™ØÃ∏",
  "npre": "‚™ØÃ∏",
  "nrarrc": "‚§≥Ã∏",
  "nrarr": "‚Üõ",
  "nrArr": "‚áè",
  "nrarrw": "‚ÜùÃ∏",
  "nrightarrow": "‚Üõ",
  "nRightarrow": "‚áè",
  "nrtri": "‚ã´",
  "nrtrie": "‚ã≠",
  "nsc": "‚äÅ",
  "nsccue": "‚ã°",
  "nsce": "‚™∞Ã∏",
  "Nscr": "ùí©",
  "nscr": "ùìÉ",
  "nshortmid": "‚à§",
  "nshortparallel": "‚à¶",
  "nsim": "‚âÅ",
  "nsime": "‚âÑ",
  "nsimeq": "‚âÑ",
  "nsmid": "‚à§",
  "nspar": "‚à¶",
  "nsqsube": "‚ã¢",
  "nsqsupe": "‚ã£",
  "nsub": "‚äÑ",
  "nsubE": "‚´ÖÃ∏",
  "nsube": "‚äà",
  "nsubset": "‚äÇ‚Éí",
  "nsubseteq": "‚äà",
  "nsubseteqq": "‚´ÖÃ∏",
  "nsucc": "‚äÅ",
  "nsucceq": "‚™∞Ã∏",
  "nsup": "‚äÖ",
  "nsupE": "‚´ÜÃ∏",
  "nsupe": "‚äâ",
  "nsupset": "‚äÉ‚Éí",
  "nsupseteq": "‚äâ",
  "nsupseteqq": "‚´ÜÃ∏",
  "ntgl": "‚âπ",
  "Ntilde": "√ë",
  "ntilde": "√±",
  "ntlg": "‚â∏",
  "ntriangleleft": "‚ã™",
  "ntrianglelefteq": "‚ã¨",
  "ntriangleright": "‚ã´",
  "ntrianglerighteq": "‚ã≠",
  "Nu": "Œù",
  "nu": "ŒΩ",
  "num": "#",
  "numero": "‚Ññ",
  "numsp": "‚Äá",
  "nvap": "‚âç‚Éí",
  "nvdash": "‚ä¨",
  "nvDash": "‚ä≠",
  "nVdash": "‚äÆ",
  "nVDash": "‚äØ",
  "nvge": "‚â•‚Éí",
  "nvgt": ">‚Éí",
  "nvHarr": "‚§Ñ",
  "nvinfin": "‚ßû",
  "nvlArr": "‚§Ç",
  "nvle": "‚â§‚Éí",
  "nvlt": "<‚Éí",
  "nvltrie": "‚ä¥‚Éí",
  "nvrArr": "‚§É",
  "nvrtrie": "‚äµ‚Éí",
  "nvsim": "‚àº‚Éí",
  "nwarhk": "‚§£",
  "nwarr": "‚Üñ",
  "nwArr": "‚áñ",
  "nwarrow": "‚Üñ",
  "nwnear": "‚§ß",
  "Oacute": "√ì",
  "oacute": "√≥",
  "oast": "‚äõ",
  "Ocirc": "√î",
  "ocirc": "√¥",
  "ocir": "‚äö",
  "Ocy": "–û",
  "ocy": "–æ",
  "odash": "‚äù",
  "Odblac": "≈ê",
  "odblac": "≈ë",
  "odiv": "‚®∏",
  "odot": "‚äô",
  "odsold": "‚¶º",
  "OElig": "≈í",
  "oelig": "≈ì",
  "ofcir": "‚¶ø",
  "Ofr": "ùîí",
  "ofr": "ùî¨",
  "ogon": "Àõ",
  "Ograve": "√í",
  "ograve": "√≤",
  "ogt": "‚ßÅ",
  "ohbar": "‚¶µ",
  "ohm": "Œ©",
  "oint": "‚àÆ",
  "olarr": "‚Ü∫",
  "olcir": "‚¶æ",
  "olcross": "‚¶ª",
  "oline": "‚Äæ",
  "olt": "‚ßÄ",
  "Omacr": "≈å",
  "omacr": "≈ç",
  "Omega": "Œ©",
  "omega": "œâ",
  "Omicron": "Œü",
  "omicron": "Œø",
  "omid": "‚¶∂",
  "ominus": "‚äñ",
  "Oopf": "ùïÜ",
  "oopf": "ùï†",
  "opar": "‚¶∑",
  "OpenCurlyDoubleQuote": "‚Äú",
  "OpenCurlyQuote": "‚Äò",
  "operp": "‚¶π",
  "oplus": "‚äï",
  "orarr": "‚Üª",
  "Or": "‚©î",
  "or": "‚à®",
  "ord": "‚©ù",
  "order": "‚Ñ¥",
  "orderof": "‚Ñ¥",
  "ordf": "¬™",
  "ordm": "¬∫",
  "origof": "‚ä∂",
  "oror": "‚©ñ",
  "orslope": "‚©ó",
  "orv": "‚©õ",
  "oS": "‚ìà",
  "Oscr": "ùí™",
  "oscr": "‚Ñ¥",
  "Oslash": "√ò",
  "oslash": "√∏",
  "osol": "‚äò",
  "Otilde": "√ï",
  "otilde": "√µ",
  "otimesas": "‚®∂",
  "Otimes": "‚®∑",
  "otimes": "‚äó",
  "Ouml": "√ñ",
  "ouml": "√∂",
  "ovbar": "‚åΩ",
  "OverBar": "‚Äæ",
  "OverBrace": "‚èû",
  "OverBracket": "‚é¥",
  "OverParenthesis": "‚èú",
  "para": "¬∂",
  "parallel": "‚à•",
  "par": "‚à•",
  "parsim": "‚´≥",
  "parsl": "‚´Ω",
  "part": "‚àÇ",
  "PartialD": "‚àÇ",
  "Pcy": "–ü",
  "pcy": "–ø",
  "percnt": "%",
  "period": ".",
  "permil": "‚Ä∞",
  "perp": "‚ä•",
  "pertenk": "‚Ä±",
  "Pfr": "ùîì",
  "pfr": "ùî≠",
  "Phi": "Œ¶",
  "phi": "œÜ",
  "phiv": "œï",
  "phmmat": "‚Ñ≥",
  "phone": "‚òé",
  "Pi": "Œ†",
  "pi": "œÄ",
  "pitchfork": "‚ãî",
  "piv": "œñ",
  "planck": "‚Ñè",
  "planckh": "‚Ñé",
  "plankv": "‚Ñè",
  "plusacir": "‚®£",
  "plusb": "‚äû",
  "pluscir": "‚®¢",
  "plus": "+",
  "plusdo": "‚àî",
  "plusdu": "‚®•",
  "pluse": "‚©≤",
  "PlusMinus": "¬±",
  "plusmn": "¬±",
  "plussim": "‚®¶",
  "plustwo": "‚®ß",
  "pm": "¬±",
  "Poincareplane": "‚Ñå",
  "pointint": "‚®ï",
  "popf": "ùï°",
  "Popf": "‚Ñô",
  "pound": "¬£",
  "prap": "‚™∑",
  "Pr": "‚™ª",
  "pr": "‚â∫",
  "prcue": "‚âº",
  "precapprox": "‚™∑",
  "prec": "‚â∫",
  "preccurlyeq": "‚âº",
  "Precedes": "‚â∫",
  "PrecedesEqual": "‚™Ø",
  "PrecedesSlantEqual": "‚âº",
  "PrecedesTilde": "‚âæ",
  "preceq": "‚™Ø",
  "precnapprox": "‚™π",
  "precneqq": "‚™µ",
  "precnsim": "‚ã®",
  "pre": "‚™Ø",
  "prE": "‚™≥",
  "precsim": "‚âæ",
  "prime": "‚Ä≤",
  "Prime": "‚Ä≥",
  "primes": "‚Ñô",
  "prnap": "‚™π",
  "prnE": "‚™µ",
  "prnsim": "‚ã®",
  "prod": "‚àè",
  "Product": "‚àè",
  "profalar": "‚åÆ",
  "profline": "‚åí",
  "profsurf": "‚åì",
  "prop": "‚àù",
  "Proportional": "‚àù",
  "Proportion": "‚à∑",
  "propto": "‚àù",
  "prsim": "‚âæ",
  "prurel": "‚ä∞",
  "Pscr": "ùí´",
  "pscr": "ùìÖ",
  "Psi": "Œ®",
  "psi": "œà",
  "puncsp": "‚Äà",
  "Qfr": "ùîî",
  "qfr": "ùîÆ",
  "qint": "‚®å",
  "qopf": "ùï¢",
  "Qopf": "‚Ñö",
  "qprime": "‚Åó",
  "Qscr": "ùí¨",
  "qscr": "ùìÜ",
  "quaternions": "‚Ñç",
  "quatint": "‚®ñ",
  "quest": "?",
  "questeq": "‚âü",
  "quot": "\"",
  "QUOT": "\"",
  "rAarr": "‚áõ",
  "race": "‚àΩÃ±",
  "Racute": "≈î",
  "racute": "≈ï",
  "radic": "‚àö",
  "raemptyv": "‚¶≥",
  "rang": "‚ü©",
  "Rang": "‚ü´",
  "rangd": "‚¶í",
  "range": "‚¶•",
  "rangle": "‚ü©",
  "raquo": "¬ª",
  "rarrap": "‚•µ",
  "rarrb": "‚á•",
  "rarrbfs": "‚§†",
  "rarrc": "‚§≥",
  "rarr": "‚Üí",
  "Rarr": "‚Ü†",
  "rArr": "‚áí",
  "rarrfs": "‚§û",
  "rarrhk": "‚Ü™",
  "rarrlp": "‚Ü¨",
  "rarrpl": "‚•Ö",
  "rarrsim": "‚•¥",
  "Rarrtl": "‚§ñ",
  "rarrtl": "‚Ü£",
  "rarrw": "‚Üù",
  "ratail": "‚§ö",
  "rAtail": "‚§ú",
  "ratio": "‚à∂",
  "rationals": "‚Ñö",
  "rbarr": "‚§ç",
  "rBarr": "‚§è",
  "RBarr": "‚§ê",
  "rbbrk": "‚ù≥",
  "rbrace": "}",
  "rbrack": "]",
  "rbrke": "‚¶å",
  "rbrksld": "‚¶é",
  "rbrkslu": "‚¶ê",
  "Rcaron": "≈ò",
  "rcaron": "≈ô",
  "Rcedil": "≈ñ",
  "rcedil": "≈ó",
  "rceil": "‚åâ",
  "rcub": "}",
  "Rcy": "–†",
  "rcy": "—Ä",
  "rdca": "‚§∑",
  "rdldhar": "‚•©",
  "rdquo": "‚Äù",
  "rdquor": "‚Äù",
  "rdsh": "‚Ü≥",
  "real": "‚Ñú",
  "realine": "‚Ñõ",
  "realpart": "‚Ñú",
  "reals": "‚Ñù",
  "Re": "‚Ñú",
  "rect": "‚ñ≠",
  "reg": "¬Æ",
  "REG": "¬Æ",
  "ReverseElement": "‚àã",
  "ReverseEquilibrium": "‚áã",
  "ReverseUpEquilibrium": "‚•Ø",
  "rfisht": "‚•Ω",
  "rfloor": "‚åã",
  "rfr": "ùîØ",
  "Rfr": "‚Ñú",
  "rHar": "‚•§",
  "rhard": "‚áÅ",
  "rharu": "‚áÄ",
  "rharul": "‚•¨",
  "Rho": "Œ°",
  "rho": "œÅ",
  "rhov": "œ±",
  "RightAngleBracket": "‚ü©",
  "RightArrowBar": "‚á•",
  "rightarrow": "‚Üí",
  "RightArrow": "‚Üí",
  "Rightarrow": "‚áí",
  "RightArrowLeftArrow": "‚áÑ",
  "rightarrowtail": "‚Ü£",
  "RightCeiling": "‚åâ",
  "RightDoubleBracket": "‚üß",
  "RightDownTeeVector": "‚•ù",
  "RightDownVectorBar": "‚•ï",
  "RightDownVector": "‚áÇ",
  "RightFloor": "‚åã",
  "rightharpoondown": "‚áÅ",
  "rightharpoonup": "‚áÄ",
  "rightleftarrows": "‚áÑ",
  "rightleftharpoons": "‚áå",
  "rightrightarrows": "‚áâ",
  "rightsquigarrow": "‚Üù",
  "RightTeeArrow": "‚Ü¶",
  "RightTee": "‚ä¢",
  "RightTeeVector": "‚•õ",
  "rightthreetimes": "‚ãå",
  "RightTriangleBar": "‚ßê",
  "RightTriangle": "‚ä≥",
  "RightTriangleEqual": "‚äµ",
  "RightUpDownVector": "‚•è",
  "RightUpTeeVector": "‚•ú",
  "RightUpVectorBar": "‚•î",
  "RightUpVector": "‚Üæ",
  "RightVectorBar": "‚•ì",
  "RightVector": "‚áÄ",
  "ring": "Àö",
  "risingdotseq": "‚âì",
  "rlarr": "‚áÑ",
  "rlhar": "‚áå",
  "rlm": "‚Äè",
  "rmoustache": "‚é±",
  "rmoust": "‚é±",
  "rnmid": "‚´Æ",
  "roang": "‚ü≠",
  "roarr": "‚áæ",
  "robrk": "‚üß",
  "ropar": "‚¶Ü",
  "ropf": "ùï£",
  "Ropf": "‚Ñù",
  "roplus": "‚®Æ",
  "rotimes": "‚®µ",
  "RoundImplies": "‚•∞",
  "rpar": ")",
  "rpargt": "‚¶î",
  "rppolint": "‚®í",
  "rrarr": "‚áâ",
  "Rrightarrow": "‚áõ",
  "rsaquo": "‚Ä∫",
  "rscr": "ùìá",
  "Rscr": "‚Ñõ",
  "rsh": "‚Ü±",
  "Rsh": "‚Ü±",
  "rsqb": "]",
  "rsquo": "‚Äô",
  "rsquor": "‚Äô",
  "rthree": "‚ãå",
  "rtimes": "‚ãä",
  "rtri": "‚ñπ",
  "rtrie": "‚äµ",
  "rtrif": "‚ñ∏",
  "rtriltri": "‚ßé",
  "RuleDelayed": "‚ß¥",
  "ruluhar": "‚•®",
  "rx": "‚Ñû",
  "Sacute": "≈ö",
  "sacute": "≈õ",
  "sbquo": "‚Äö",
  "scap": "‚™∏",
  "Scaron": "≈†",
  "scaron": "≈°",
  "Sc": "‚™º",
  "sc": "‚âª",
  "sccue": "‚âΩ",
  "sce": "‚™∞",
  "scE": "‚™¥",
  "Scedil": "≈û",
  "scedil": "≈ü",
  "Scirc": "≈ú",
  "scirc": "≈ù",
  "scnap": "‚™∫",
  "scnE": "‚™∂",
  "scnsim": "‚ã©",
  "scpolint": "‚®ì",
  "scsim": "‚âø",
  "Scy": "–°",
  "scy": "—Å",
  "sdotb": "‚ä°",
  "sdot": "‚ãÖ",
  "sdote": "‚©¶",
  "searhk": "‚§•",
  "searr": "‚Üò",
  "seArr": "‚áò",
  "searrow": "‚Üò",
  "sect": "¬ß",
  "semi": ";",
  "seswar": "‚§©",
  "setminus": "‚àñ",
  "setmn": "‚àñ",
  "sext": "‚ú∂",
  "Sfr": "ùîñ",
  "sfr": "ùî∞",
  "sfrown": "‚å¢",
  "sharp": "‚ôØ",
  "SHCHcy": "–©",
  "shchcy": "—â",
  "SHcy": "–®",
  "shcy": "—à",
  "ShortDownArrow": "‚Üì",
  "ShortLeftArrow": "‚Üê",
  "shortmid": "‚à£",
  "shortparallel": "‚à•",
  "ShortRightArrow": "‚Üí",
  "ShortUpArrow": "‚Üë",
  "shy": "¬≠",
  "Sigma": "Œ£",
  "sigma": "œÉ",
  "sigmaf": "œÇ",
  "sigmav": "œÇ",
  "sim": "‚àº",
  "simdot": "‚©™",
  "sime": "‚âÉ",
  "simeq": "‚âÉ",
  "simg": "‚™û",
  "simgE": "‚™†",
  "siml": "‚™ù",
  "simlE": "‚™ü",
  "simne": "‚âÜ",
  "simplus": "‚®§",
  "simrarr": "‚•≤",
  "slarr": "‚Üê",
  "SmallCircle": "‚àò",
  "smallsetminus": "‚àñ",
  "smashp": "‚®≥",
  "smeparsl": "‚ß§",
  "smid": "‚à£",
  "smile": "‚å£",
  "smt": "‚™™",
  "smte": "‚™¨",
  "smtes": "‚™¨Ô∏Ä",
  "SOFTcy": "–¨",
  "softcy": "—å",
  "solbar": "‚åø",
  "solb": "‚ßÑ",
  "sol": "/",
  "Sopf": "ùïä",
  "sopf": "ùï§",
  "spades": "‚ô†",
  "spadesuit": "‚ô†",
  "spar": "‚à•",
  "sqcap": "‚äì",
  "sqcaps": "‚äìÔ∏Ä",
  "sqcup": "‚äî",
  "sqcups": "‚äîÔ∏Ä",
  "Sqrt": "‚àö",
  "sqsub": "‚äè",
  "sqsube": "‚äë",
  "sqsubset": "‚äè",
  "sqsubseteq": "‚äë",
  "sqsup": "‚äê",
  "sqsupe": "‚äí",
  "sqsupset": "‚äê",
  "sqsupseteq": "‚äí",
  "square": "‚ñ°",
  "Square": "‚ñ°",
  "SquareIntersection": "‚äì",
  "SquareSubset": "‚äè",
  "SquareSubsetEqual": "‚äë",
  "SquareSuperset": "‚äê",
  "SquareSupersetEqual": "‚äí",
  "SquareUnion": "‚äî",
  "squarf": "‚ñ™",
  "squ": "‚ñ°",
  "squf": "‚ñ™",
  "srarr": "‚Üí",
  "Sscr": "ùíÆ",
  "sscr": "ùìà",
  "ssetmn": "‚àñ",
  "ssmile": "‚å£",
  "sstarf": "‚ãÜ",
  "Star": "‚ãÜ",
  "star": "‚òÜ",
  "starf": "‚òÖ",
  "straightepsilon": "œµ",
  "straightphi": "œï",
  "strns": "¬Ø",
  "sub": "‚äÇ",
  "Sub": "‚ãê",
  "subdot": "‚™Ω",
  "subE": "‚´Ö",
  "sube": "‚äÜ",
  "subedot": "‚´É",
  "submult": "‚´Å",
  "subnE": "‚´ã",
  "subne": "‚ää",
  "subplus": "‚™ø",
  "subrarr": "‚•π",
  "subset": "‚äÇ",
  "Subset": "‚ãê",
  "subseteq": "‚äÜ",
  "subseteqq": "‚´Ö",
  "SubsetEqual": "‚äÜ",
  "subsetneq": "‚ää",
  "subsetneqq": "‚´ã",
  "subsim": "‚´á",
  "subsub": "‚´ï",
  "subsup": "‚´ì",
  "succapprox": "‚™∏",
  "succ": "‚âª",
  "succcurlyeq": "‚âΩ",
  "Succeeds": "‚âª",
  "SucceedsEqual": "‚™∞",
  "SucceedsSlantEqual": "‚âΩ",
  "SucceedsTilde": "‚âø",
  "succeq": "‚™∞",
  "succnapprox": "‚™∫",
  "succneqq": "‚™∂",
  "succnsim": "‚ã©",
  "succsim": "‚âø",
  "SuchThat": "‚àã",
  "sum": "‚àë",
  "Sum": "‚àë",
  "sung": "‚ô™",
  "sup1": "¬π",
  "sup2": "¬≤",
  "sup3": "¬≥",
  "sup": "‚äÉ",
  "Sup": "‚ãë",
  "supdot": "‚™æ",
  "supdsub": "‚´ò",
  "supE": "‚´Ü",
  "supe": "‚äá",
  "supedot": "‚´Ñ",
  "Superset": "‚äÉ",
  "SupersetEqual": "‚äá",
  "suphsol": "‚üâ",
  "suphsub": "‚´ó",
  "suplarr": "‚•ª",
  "supmult": "‚´Ç",
  "supnE": "‚´å",
  "supne": "‚äã",
  "supplus": "‚´Ä",
  "supset": "‚äÉ",
  "Supset": "‚ãë",
  "supseteq": "‚äá",
  "supseteqq": "‚´Ü",
  "supsetneq": "‚äã",
  "supsetneqq": "‚´å",
  "supsim": "‚´à",
  "supsub": "‚´î",
  "supsup": "‚´ñ",
  "swarhk": "‚§¶",
  "swarr": "‚Üô",
  "swArr": "‚áô",
  "swarrow": "‚Üô",
  "swnwar": "‚§™",
  "szlig": "√ü",
  "Tab": "\t",
  "target": "‚åñ",
  "Tau": "Œ§",
  "tau": "œÑ",
  "tbrk": "‚é¥",
  "Tcaron": "≈§",
  "tcaron": "≈•",
  "Tcedil": "≈¢",
  "tcedil": "≈£",
  "Tcy": "–¢",
  "tcy": "—Ç",
  "tdot": "‚Éõ",
  "telrec": "‚åï",
  "Tfr": "ùîó",
  "tfr": "ùî±",
  "there4": "‚à¥",
  "therefore": "‚à¥",
  "Therefore": "‚à¥",
  "Theta": "Œò",
  "theta": "Œ∏",
  "thetasym": "œë",
  "thetav": "œë",
  "thickapprox": "‚âà",
  "thicksim": "‚àº",
  "ThickSpace": "‚Åü‚Ää",
  "ThinSpace": "‚Äâ",
  "thinsp": "‚Äâ",
  "thkap": "‚âà",
  "thksim": "‚àº",
  "THORN": "√û",
  "thorn": "√æ",
  "tilde": "Àú",
  "Tilde": "‚àº",
  "TildeEqual": "‚âÉ",
  "TildeFullEqual": "‚âÖ",
  "TildeTilde": "‚âà",
  "timesbar": "‚®±",
  "timesb": "‚ä†",
  "times": "√ó",
  "timesd": "‚®∞",
  "tint": "‚à≠",
  "toea": "‚§®",
  "topbot": "‚å∂",
  "topcir": "‚´±",
  "top": "‚ä§",
  "Topf": "ùïã",
  "topf": "ùï•",
  "topfork": "‚´ö",
  "tosa": "‚§©",
  "tprime": "‚Ä¥",
  "trade": "‚Ñ¢",
  "TRADE": "‚Ñ¢",
  "triangle": "‚ñµ",
  "triangledown": "‚ñø",
  "triangleleft": "‚óÉ",
  "trianglelefteq": "‚ä¥",
  "triangleq": "‚âú",
  "triangleright": "‚ñπ",
  "trianglerighteq": "‚äµ",
  "tridot": "‚ó¨",
  "trie": "‚âú",
  "triminus": "‚®∫",
  "TripleDot": "‚Éõ",
  "triplus": "‚®π",
  "trisb": "‚ßç",
  "tritime": "‚®ª",
  "trpezium": "‚è¢",
  "Tscr": "ùíØ",
  "tscr": "ùìâ",
  "TScy": "–¶",
  "tscy": "—Ü",
  "TSHcy": "–ã",
  "tshcy": "—õ",
  "Tstrok": "≈¶",
  "tstrok": "≈ß",
  "twixt": "‚â¨",
  "twoheadleftarrow": "‚Üû",
  "twoheadrightarrow": "‚Ü†",
  "Uacute": "√ö",
  "uacute": "√∫",
  "uarr": "‚Üë",
  "Uarr": "‚Üü",
  "uArr": "‚áë",
  "Uarrocir": "‚•â",
  "Ubrcy": "–é",
  "ubrcy": "—û",
  "Ubreve": "≈¨",
  "ubreve": "≈≠",
  "Ucirc": "√õ",
  "ucirc": "√ª",
  "Ucy": "–£",
  "ucy": "—É",
  "udarr": "‚áÖ",
  "Udblac": "≈∞",
  "udblac": "≈±",
  "udhar": "‚•Æ",
  "ufisht": "‚•æ",
  "Ufr": "ùîò",
  "ufr": "ùî≤",
  "Ugrave": "√ô",
  "ugrave": "√π",
  "uHar": "‚•£",
  "uharl": "‚Üø",
  "uharr": "‚Üæ",
  "uhblk": "‚ñÄ",
  "ulcorn": "‚åú",
  "ulcorner": "‚åú",
  "ulcrop": "‚åè",
  "ultri": "‚ó∏",
  "Umacr": "≈™",
  "umacr": "≈´",
  "uml": "¬®",
  "UnderBar": "_",
  "UnderBrace": "‚èü",
  "UnderBracket": "‚éµ",
  "UnderParenthesis": "‚èù",
  "Union": "‚ãÉ",
  "UnionPlus": "‚äé",
  "Uogon": "≈≤",
  "uogon": "≈≥",
  "Uopf": "ùïå",
  "uopf": "ùï¶",
  "UpArrowBar": "‚§í",
  "uparrow": "‚Üë",
  "UpArrow": "‚Üë",
  "Uparrow": "‚áë",
  "UpArrowDownArrow": "‚áÖ",
  "updownarrow": "‚Üï",
  "UpDownArrow": "‚Üï",
  "Updownarrow": "‚áï",
  "UpEquilibrium": "‚•Æ",
  "upharpoonleft": "‚Üø",
  "upharpoonright": "‚Üæ",
  "uplus": "‚äé",
  "UpperLeftArrow": "‚Üñ",
  "UpperRightArrow": "‚Üó",
  "upsi": "œÖ",
  "Upsi": "œí",
  "upsih": "œí",
  "Upsilon": "Œ•",
  "upsilon": "œÖ",
  "UpTeeArrow": "‚Ü•",
  "UpTee": "‚ä•",
  "upuparrows": "‚áà",
  "urcorn": "‚åù",
  "urcorner": "‚åù",
  "urcrop": "‚åé",
  "Uring": "≈Æ",
  "uring": "≈Ø",
  "urtri": "‚óπ",
  "Uscr": "ùí∞",
  "uscr": "ùìä",
  "utdot": "‚ã∞",
  "Utilde": "≈®",
  "utilde": "≈©",
  "utri": "‚ñµ",
  "utrif": "‚ñ¥",
  "uuarr": "‚áà",
  "Uuml": "√ú",
  "uuml": "√º",
  "uwangle": "‚¶ß",
  "vangrt": "‚¶ú",
  "varepsilon": "œµ",
  "varkappa": "œ∞",
  "varnothing": "‚àÖ",
  "varphi": "œï",
  "varpi": "œñ",
  "varpropto": "‚àù",
  "varr": "‚Üï",
  "vArr": "‚áï",
  "varrho": "œ±",
  "varsigma": "œÇ",
  "varsubsetneq": "‚ääÔ∏Ä",
  "varsubsetneqq": "‚´ãÔ∏Ä",
  "varsupsetneq": "‚äãÔ∏Ä",
  "varsupsetneqq": "‚´åÔ∏Ä",
  "vartheta": "œë",
  "vartriangleleft": "‚ä≤",
  "vartriangleright": "‚ä≥",
  "vBar": "‚´®",
  "Vbar": "‚´´",
  "vBarv": "‚´©",
  "Vcy": "–í",
  "vcy": "–≤",
  "vdash": "‚ä¢",
  "vDash": "‚ä®",
  "Vdash": "‚ä©",
  "VDash": "‚ä´",
  "Vdashl": "‚´¶",
  "veebar": "‚äª",
  "vee": "‚à®",
  "Vee": "‚ãÅ",
  "veeeq": "‚âö",
  "vellip": "‚ãÆ",
  "verbar": "|",
  "Verbar": "‚Äñ",
  "vert": "|",
  "Vert": "‚Äñ",
  "VerticalBar": "‚à£",
  "VerticalLine": "|",
  "VerticalSeparator": "‚ùò",
  "VerticalTilde": "‚âÄ",
  "VeryThinSpace": "‚Ää",
  "Vfr": "ùîô",
  "vfr": "ùî≥",
  "vltri": "‚ä≤",
  "vnsub": "‚äÇ‚Éí",
  "vnsup": "‚äÉ‚Éí",
  "Vopf": "ùïç",
  "vopf": "ùïß",
  "vprop": "‚àù",
  "vrtri": "‚ä≥",
  "Vscr": "ùí±",
  "vscr": "ùìã",
  "vsubnE": "‚´ãÔ∏Ä",
  "vsubne": "‚ääÔ∏Ä",
  "vsupnE": "‚´åÔ∏Ä",
  "vsupne": "‚äãÔ∏Ä",
  "Vvdash": "‚ä™",
  "vzigzag": "‚¶ö",
  "Wcirc": "≈¥",
  "wcirc": "≈µ",
  "wedbar": "‚©ü",
  "wedge": "‚àß",
  "Wedge": "‚ãÄ",
  "wedgeq": "‚âô",
  "weierp": "‚Ñò",
  "Wfr": "ùîö",
  "wfr": "ùî¥",
  "Wopf": "ùïé",
  "wopf": "ùï®",
  "wp": "‚Ñò",
  "wr": "‚âÄ",
  "wreath": "‚âÄ",
  "Wscr": "ùí≤",
  "wscr": "ùìå",
  "xcap": "‚ãÇ",
  "xcirc": "‚óØ",
  "xcup": "‚ãÉ",
  "xdtri": "‚ñΩ",
  "Xfr": "ùîõ",
  "xfr": "ùîµ",
  "xharr": "‚ü∑",
  "xhArr": "‚ü∫",
  "Xi": "Œû",
  "xi": "Œæ",
  "xlarr": "‚üµ",
  "xlArr": "‚ü∏",
  "xmap": "‚üº",
  "xnis": "‚ãª",
  "xodot": "‚®Ä",
  "Xopf": "ùïè",
  "xopf": "ùï©",
  "xoplus": "‚®Å",
  "xotime": "‚®Ç",
  "xrarr": "‚ü∂",
  "xrArr": "‚üπ",
  "Xscr": "ùí≥",
  "xscr": "ùìç",
  "xsqcup": "‚®Ü",
  "xuplus": "‚®Ñ",
  "xutri": "‚ñ≥",
  "xvee": "‚ãÅ",
  "xwedge": "‚ãÄ",
  "Yacute": "√ù",
  "yacute": "√Ω",
  "YAcy": "–Ø",
  "yacy": "—è",
  "Ycirc": "≈∂",
  "ycirc": "≈∑",
  "Ycy": "–´",
  "ycy": "—ã",
  "yen": "¬•",
  "Yfr": "ùîú",
  "yfr": "ùî∂",
  "YIcy": "–á",
  "yicy": "—ó",
  "Yopf": "ùïê",
  "yopf": "ùï™",
  "Yscr": "ùí¥",
  "yscr": "ùìé",
  "YUcy": "–Æ",
  "yucy": "—é",
  "yuml": "√ø",
  "Yuml": "≈∏",
  "Zacute": "≈π",
  "zacute": "≈∫",
  "Zcaron": "≈Ω",
  "zcaron": "≈æ",
  "Zcy": "–ó",
  "zcy": "–∑",
  "Zdot": "≈ª",
  "zdot": "≈º",
  "zeetrf": "‚Ñ®",
  "ZeroWidthSpace": "‚Äã",
  "Zeta": "Œñ",
  "zeta": "Œ∂",
  "zfr": "ùî∑",
  "Zfr": "‚Ñ®",
  "ZHcy": "–ñ",
  "zhcy": "–∂",
  "zigrarr": "‚áù",
  "zopf": "ùï´",
  "Zopf": "‚Ñ§",
  "Zscr": "ùíµ",
  "zscr": "ùìè",
  "zwj": "‚Äç",
  "zwnj": "‚Äå"
};
}],
[/* 6 */ 'uc.micro', '/categories/P/regex.js', function(exports, module, __filename, __dirname, __meta) {
module.exports=/[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/
}],
[/* 7 */ 'mdurl', '/index.js', function(exports, module, __filename, __dirname, __meta) {
'use strict';


module.exports.encode = __node_require__(8 /* './encode' */);
module.exports.decode = __node_require__(9 /* './decode' */);
module.exports.format = __node_require__(10 /* './format' */);
module.exports.parse  = __node_require__(11 /* './parse' */);
}],
[/* 8 */ 'mdurl', '/encode.js', function(exports, module, __filename, __dirname, __meta) {
'use strict';


var encodeCache = {};


// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) { return cache; }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}


// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i, l, code, nextCode, cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped  = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";


module.exports = encode;
}],
[/* 9 */ 'mdurl', '/decode.js', function(exports, module, __filename, __dirname, __meta) {
'use strict';


/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i, ch, cache = decodeCache[exclude];
  if (cache) { return cache; }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}


// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    var i, l, b1, b2, b3, b4, chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);

          if (chr < 0x80) {
            result += '\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);

          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {
            result += '\ufffd\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\ufffd\ufffd\ufffd\ufffd';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\ufffd';
    }

    return result;
  });
}


decode.defaultChars   = ';/?:@&=+$,#';
decode.componentChars = '';


module.exports = decode;
}],
[/* 10 */ 'mdurl', '/format.js', function(exports, module, __filename, __dirname, __meta) {
'use strict';


module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};
}],
[/* 11 */ 'mdurl', '/parse.js', function(exports, module, __filename, __dirname, __meta) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = [ '<', '>', '"', '`', ' ', '\r', '\n', '\t' ],

    // RFC 2396: characters not allowed for various reasons.
    unwise = [ '{', '}', '|', '\\', '^', '`' ].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = [ '\'' ].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),
    hostEndingChars = [ '/', '?', '#' ],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    /* eslint-disable no-script-url */
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    };
    /* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, slashesDenoteHost) {
  var i, l, lowerProto, hec, slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') { hostEnd--; }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function(host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

module.exports = urlParse;
}],
[/* 12 */ 'uc.micro', '/index.js', function(exports, module, __filename, __dirname, __meta) {
'use strict';

exports.Any = __node_require__(13 /* './properties/Any/regex' */);
exports.Cc  = __node_require__(14 /* './categories/Cc/regex' */);
exports.Cf  = __node_require__(15 /* './categories/Cf/regex' */);
exports.P   = __node_require__(6 /* './categories/P/regex' */);
exports.Z   = __node_require__(16 /* './categories/Z/regex' */);
}],
[/* 13 */ 'uc.micro', '/properties/Any/regex.js', function(exports, module, __filename, __dirname, __meta) {
module.exports=/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
}],
[/* 14 */ 'uc.micro', '/categories/Cc/regex.js', function(exports, module, __filename, __dirname, __meta) {
module.exports=/[\0-\x1F\x7F-\x9F]/
}],
[/* 15 */ 'uc.micro', '/categories/Cf/regex.js', function(exports, module, __filename, __dirname, __meta) {
module.exports=/[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/
}],
[/* 16 */ 'uc.micro', '/categories/Z/regex.js', function(exports, module, __filename, __dirname, __meta) {
module.exports=/[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
}]
];

var __node_cache__ = [];

function __node_error__(location) {
  var err = new Error('Cannot find module \'' + location + '\'');
  err.code = 'MODULE_NOT_FOUND';
  throw err;
}

function __node_require__(id) {
  if ((id >>> 0) !== id || id > __node_modules__.length)
    return __node_error__(id);

  while (__node_cache__.length <= id)
    __node_cache__.push(null);

  var cache = __node_cache__[id];

  if (cache)
    return cache.exports;

  var mod = __node_modules__[id];
  var name = mod[0];
  var path = mod[1];
  var func = mod[2];
  var meta;

  var _exports = exports;
  var _module = module;

  if (id !== 0) {
    _exports = {};
    _module = {
      id: '/' + name + path,
      exports: _exports,
      parent: module.parent,
      filename: module.filename,
      loaded: false,
      children: module.children,
      paths: module.paths
    };
  }

  __node_cache__[id] = _module;

  try {
    func.call(_exports, _exports, _module,
              __filename, __dirname, meta);
  } catch (e) {
    __node_cache__[id] = null;
    throw e;
  }

  __node_modules__[id] = null;

  if (id !== 0)
    _module.loaded = true;

  return _module.exports;
}

__node_require__(0);
